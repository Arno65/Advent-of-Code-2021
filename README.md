# Advent of Code 2021

This repository contains most of my solutions for Advent of Code 2021.
My main programming language is Haskell. I do some work in Swift. And I'm learning bits of Lisp and Rust.
For collecting the stars I will first code the solution in the language that works best for me. 
Most of the time that will be Haskell.
The language I want to learn the most is Lisp so a second solution will be in Common Lisp (clisp) for most of the time. 
Solutions in languages like Swift, Rust, Python or whatever will be done for fun and if there is any spare time left.

Spoiler alert: All the code has the end results of the tasks in the comment section at the start of the code.
Also notice that these end results are obtained with the puzzle inputs from my Advent-of-Code-2021 account.

Day 1 has solutions in Haskell, (old school) BASIC, Common Lisp, Rust and Swift.\
(The Haskell code has three different solutions for counting the measurement increases.) 

Day 2 has solutions in Haskell, Common Lisp, Rust and Swift.

For the time being... for day 3 there is only a complete Haskell solution.\
I'm working on a Common Lisp version.
The current Lisp version in GIT is only working for part 1.

Day 4 has a Haskell solution.

Day 5 has a Haskell solution. There is a Common Lisp solution for part 1.\
For debug reasons the functions for drawing horizontal, vertical and diagonal lines are seperated.
The code will run much faster if they are combined, but for this task the code is fast enough.\
I'm not happy with my Lisp code. I needed a lot of functions to parse the input file to the line coordinates.

Day 6 has solutions in Haskell, Common Lisp and Rust.\
I first started part 1 in Haskell with a slow and memory inefficient list expanding iteration function.
That function is not used anymore but it's still present in the Haskell code. 

Day 7 has solutions in Haskell and Common Lisp. \
The Lisp solution has the same algorithm as the Haskell version and with the Common Lisp interpreter it is slow.

Day 8 has a Haskell solution. \
Part 2 took me multiple hours to solve and code. The solution works 0K for this task but is not generic.

Day 9 solutions in Haskell and Common Lisp. (In Lisp there is only code for part 1.) \
My first 'flood fill' version for Part 2 was very slow and memory consuming. I'm happy with the current solution.

Day 10 has solutions in Haskell and Common Lisp. \
Day 11 has a Haskell solution.

The (ugly) Haskell code for day 12 will be recoded completely. \
(That will be done sometime in 2022...) \
The program 'pathFinder.hs' for building the graph is good enough for sharing.

Day 13 has a Haskell solution. \
Day 14 has a Haskell solution.

Day 15 has a Swift solution. \
I have a Haskell solution, fast enough for part 1 but much too slow for part 2.

Day 16 has a Haskell solution. \
Evaluation and pattern matching work so good together.

Day 17 has a Haskell solution.

Both solutions for day 18 and day 19 need rework and a lot of cleaning up. \
(Recoding will be done sometime in 2022.)

Day 20 has a Haskell solution. \
Day 21 has a Haskell solution. 

For part 1 of day 22 there is a brute force (and still fast) solution in Swift. \
I like to have a (smart) soltution in Haskell but I'm still strugling with a that.

The solutions for day 23 where done by hand. (Only used some code to sum the costs.) 

Day 25 has a Haskell solution.
